name: Content Gap Analyzer for Aspose

on:
  workflow_dispatch:
    inputs:
      product:
        description: "Product to analyze"
        required: true
        type: choice
        options:
          - "cells"
        default: "cells"
      platform:
        description: "Platform to analyze"
        required: true
        type: choice
        options:
          - "net"
          - "java"
          - "python_net"
          - "cpp"
          - "android"
          - "nodejs"
        default: "net"
      mode:
        description: "Pipeline mode to run"
        required: true
        type: choice
        options:
          - "index"
          - "coverage"
          - "semantic-coverage"
          - "semantic-analyze"
          - "analyze"
          - "run-all"
        default: "run-all"
      case:
        description: "Semantic coverage case"
        required: false
        type: choice
        options:
          - ""
          - "docs_to_blogs"
          - "docs_to_tutorials"
          - "blogs_to_blogs"
        default: ""
      flush:
        description: "Clear cache/output before running"
        required: false
        type: boolean
        default: false
      force:
        description: "Force re-run even if step is complete"
        required: false
        type: boolean
        default: false

permissions:
  contents: write

jobs:
  analyze:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Verify PAT can access required GitHub repos
        env:
          ASPOSE_BLOG_TOKEN: ${{ secrets.ASPOSE_BLOG_TOKEN }}
        run: |
          set -euo pipefail

          if [ -z "${ASPOSE_BLOG_TOKEN:-}" ]; then
            echo "ASPOSE_BLOG_TOKEN is empty or not available to this run."
            exit 1
          fi

          echo "1) Checking via GitHub API (does not expose token)..."
          check_repo_api () {
            local repo="$1"
            local code
            code="$(curl -sS -o /dev/null -w "%{http_code}" \
              -H "Authorization: Bearer ${ASPOSE_BLOG_TOKEN}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${repo}")"
            echo "API access ${repo}: HTTP ${code}"
            if [ "${code}" != "200" ]; then
              echo "FAIL: Token cannot access ${repo}. (401=bad token, 404=no access/repo, 403=SSO/policy)"
              exit 1
            fi
          }

          # Add any repos your pipeline will clone
          check_repo_api "Aspose/aspose-blog"
          check_repo_api "aspose-cells/Aspose.Cells-Doc-md"
          check_repo_api "aspose-cells/Aspose.Cells-API-References"
          check_repo_api "aspose-cells/Aspose-Cells-Tutorials"

          echo
          echo "2) Checking via git (GIT_ASKPASS, token never in URL)..."
          cat > /tmp/git-askpass.sh <<'EOF'
          #!/usr/bin/env bash
          # Git calls askpass for both username and password prompts.
          case "$1" in
            *Username*) echo "x-access-token" ;;
            *Password*) echo "${ASPOSE_BLOG_TOKEN}" ;;
            *) echo "${ASPOSE_BLOG_TOKEN}" ;;
          esac
          EOF
              chmod +x /tmp/git-askpass.sh

              export GIT_ASKPASS=/tmp/git-askpass.sh
              export GIT_TERMINAL_PROMPT=0

              # This validates Git protocol auth without cloning a full repo.
              git ls-remote https://github.com/Aspose/aspose-blog.git HEAD >/dev/null
              git ls-remote https://github.com/aspose-cells/Aspose.Cells-Doc-md.git HEAD >/dev/null

              echo "PAT authentication checks passed."


      - name: Show git url rewrite rules (safe)
        run: |
          git config --global --get-regexp '^url\..*\.insteadOf$' || true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run Aspose Blog Analysis
        working-directory: ${{ github.workspace }}
        env:
          GIT_TERMINAL_PROMPT: "0"
          PROFESSIONALIZE_API_KEY: ${{ secrets.PROFESSIONALIZE_API_KEY }}
          PROFESSIONALIZE_BASE_URL: ${{ secrets.PROFESSIONALIZE_BASE_URL }}
          PROFESSIONALIZE_LLM_MODEL: ${{ secrets.PROFESSIONALIZE_LLM_MODEL }}
          PROFESSIONALIZE_EMBEDDING_MODEL: ${{ secrets.PROFESSIONALIZE_EMBEDDING_MODEL }}
        run: |
          set -euo pipefail

          ARGS="--brand aspose --product ${{ github.event.inputs.product }} --platform ${{ github.event.inputs.platform }}"

          MODE="${{ github.event.inputs.mode }}"
          case "$MODE" in
            "index") ARGS="$ARGS --index" ;;
            "coverage") ARGS="$ARGS --coverage" ;;
            "semantic-coverage") ARGS="$ARGS --semantic-coverage" ;;
            "semantic-analyze") ARGS="$ARGS --semantic-analyze" ;;
            "analyze") ARGS="$ARGS --analyze" ;;
            "run-all") ARGS="$ARGS --run-all" ;;
          esac

          if [ -n "${{ github.event.inputs.case }}" ]; then
            ARGS="$ARGS --case ${{ github.event.inputs.case }}"
          fi
          if [ "${{ github.event.inputs.flush }}" == "true" ]; then
            ARGS="$ARGS --flush"
          fi
          if [ "${{ github.event.inputs.force }}" == "true" ]; then
            ARGS="$ARGS --force"
          fi

          echo "Running: python -m agent_engine.content_gap_agent $ARGS"
          python -m agent_engine.content_gap_agent $ARGS

      - name: Commit and push outputs
        run: |
          set -euo pipefail

          # Configure identity for the commit
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Make sure we are on the branch that triggered the workflow
          git checkout "${GITHUB_REF_NAME}"

          # Stage only what you want committed
          git add outputs/ || true

          # Commit only if there are changes
          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi

          git commit -m "Update content gap outputs (${GITHUB_RUN_ID})"

          # Rebase to reduce push failures if multiple runs happen
          git pull --rebase origin "${GITHUB_REF_NAME}"
          git push origin "HEAD:${GITHUB_REF_NAME}"
